Projects:
	☐ lexer analysis @started(19-03-05 18:58)
	☐ syntax analysis
	☐ AST tree generate
	☐ Semantic analysis
	☐ IR generate
	☐ code optimize

Main:
    ✔ Generate Simple antlr @started(19-03-04 17) @done(19-03-13 21) @lasted(1w2d3h46m41s)
    ☐ Generate AST nodes and Type nodes for at most 1 day @started(19-03-16 14)

Parser: 
	✔ change antlr extension to use @started(19-03-05 18) @done(19-03-05 18) @lasted(54m24s)

ASTNode: @today 
    ✔ Node       @done(03-16 14)
        ✔ AST (programNode) @done(03-16 17)
        ✔ Decl(define) @done(03-16 16)
            ✔ Func  @done(03-16 17)
            ✔ Class @done(03-16 17)
            ✔ Var   @done(03-16 17)
            ✘ VarList  @cancelled(03-16 17)
        ✔ Stmt @done(03-17 15)
            ✔ Block @done(03-17 15)
            ✔ Expr  @done(03-17 15)
            ✔ If (cond) @done(03-17 15)
            ✔ While @done(03-17 15)
            ✔ For 	@done(03-17 15)
            ✔ Continue @done(03-17 15)
            ✔ Break @done(03-17 15)
            ✔ Return @done(03-17 15)
            ✘ Blank @cancelled(03-17 15)
            ✘ VarDecl @cancelled(03-17 15)
        ✔ Expr @done(03-17 15)
            ✔ FuncCall @done(03-17 16) class method ?? done with 
            ✔ unary @done(03-17 16)
                ✔ suffix @done(03-17 16)
                ✔ prefix @done(03-17 16)
            ✔ lhs 	@done(03-20 21)
                ✔ memberaccess 	@done(03-17 21)
                ✔ array index(aref, subscript) 	@done(03-17 21)
            ✔ binary or and @done(03-17 16)
            ✔ new 		@done(03-17 16)
            ✔ identifier? var-decl-node @done(03-17 21)
            ✔ assign @done(03-17 17)
            ✔ this 	@done(03-17 16)
            ✔ const(literal) @done(03-17 16)
                ✔ int 	@done(03-17 16)
                ✔ string @done(03-17 16)
                ✔ bool 	@done(03-17 16)
            ✔ null 	@done(03-17 16)
        ✔ typeNode @done(03-20 18)
		☐ compare my g4 with fanzhou @high @started(03-20 18)
			typeOrVoid -> typeFuncName
			parameterDeclarationList -> paramDeclarationList
			memberDeclaration -> classBody
			typeType -> type
			nonArrayTypeType -> typeName
			conditionStatement
			loopStatement
			jumpStatement





	☐ check ASTBuilder out @today @started(19-03-18 21:27)


TypeResolve:

	✔ type 	@done(03-17 22)
		✔ array @done(03-17 22)
		✔ func, class @done(03-17 22)
		✔ int, bool, string @done(03-17 22)
		✔ null void @done(03-17 22)

	✔ Scope init @done(03-16 16)

    ☐ entity
        ☐  what is diff between type and entity

    ☐ remain may be used for asm in Scope
        static private final String KEY_PREFIX = "$"
        static private final String VAR_PREFIX = "$VAR$"
        static private final String CLASS_PREFIX = "$CLASS$"
        static private final String FUNC_PREFIX = "$FUNC$"
        static public final String ARRAY_CLASS_NAME = "__array"
        static public final String STRING_CLASS_NAME = "__string"
        static public final String THIS_PARA_NAME = "__this_para"
	
		configuration for reg size

type from Book: @critical @high @today 
    ☐ change arrayList into LinkedHashSet or not? @started(19-03-16 17:30)
	☐ add Location type
	

☐ G4 file outline with ASTBuilder:
	✔ compilationUnit @done(03-21 08)
		✔ translationUnit* EOF @done(03-21 08)
	✔ translationUnit @done(03-21 08)
		✔ variableDeclaration @done(03-21 08)
			✔ type variableDeclaratorList '' @done(03-21 09)
				✔ variableDeclarator (',' variableDeclarator)* @done(03-21 09)
					✔ Identifier ('=' expression)? @done(03-21 09)
		✘ type @cancelled(03-21 09)
			✔ type '[' ']'	# arrayType @done(03-21 09)
			✔ typeName		# nonarrayType @done(03-21 09)
				✔ Int Bool String Identifier		✔ functionDeclaration @done(03-21 10)
		✔ typeFuncName? Identifier '(' paramDeclarationList? ')' block @done(03-21 10)
			✔ typeFuncName type void @done(03-21 10)
			✔ paramDeclaration (',' paramDeclaration)* @done(03-21 10)
				✔ type Identifier @done(03-21 10)
		✔ classDeclaration @done(03-21 08)
			✔ Class Identifier '{' classBody* '}' @done(03-21 11)
				✔ functionDeclaration variableDeclaration @done(03-21 11)
	☐ statement
		☐ block
			☐ '{' blockBody* '}'									# blockStmt
				☐ statement variableDeclaration
		☐ expression ''									# exprStmt
		☐ If '(' expression ')' statement (Else statement)?	# condStmt
		☐ While '(' expression ')' statement				# whileStmt
		☐ For '(' forCondition ')' statement				# forStmt
				☐ forCondition // 474
					☐ forDeclaration (type variableDeclaratorList) ';' expression? ';' expression?    #forCondInit
					☐ expression? ';' expression? ';' expression?       #forCondNon
		☐ Continue ''				# continueStmt
		☐ Break ''					# breakStmt
		☐ Return expression? ''	# returnStmt
		☐ ''						# blankStmt
	☐ expression
		☐ // FIX: position of primary expression
		☐ primaryExpression							# primaryExpr
			☐ Identifier			# identifierExpr
			☐ This					# thisExpr
			☐ literal				# constExpr
				☐ IntLiteral StringLiteral Null (True | False)
		☐ '(' expression ')'	# subExpr
		☐ expression op = ('++' | '--')				# suffixExpr
		☐ expression '.' Identifier					# memberExpr // under lhs
		☐ arr = expression '[' sub = expression ']'	# arefExpr // under lhs
		☐ expression '(' paramList? ')'				# funcallExpr
			☐ expression (',' expression)*
		☐ // prefix unary
		☐ <assoc = right> op = ('++' | '--') expression	# prefixExpr
		☐ <assoc = right> op = ('+' | '-') expression	# prefixExpr
		☐ <assoc = right> op = ('!' | '~') expression	# prefixExpr
		☐ <assoc = right> New creator					# newExpr
			☐ typeName ('[' expression ']')+ ('[' ']')+ ('[' expression ']')+	# errorCreator
			☐ typeName ('[' expression ']')+ ('[' ']')*	# arrayCreator
			☐ typeName ('(' ')')?						# nonArrayCreator
		☐ // suffix
		☐ expression op = ('*' | '/' | '%') expression	# binaryExpr
		☐ expression op = ('+' | '-') expression		# binaryExpr
		☐ // shift
		☐ expression op = ('<<' | '>>') expression # binaryExpr
		☐ // compare
		☐ expression op = ('<' | '>') expression	# binaryExpr
		☐ expression op = ('<=' | '>=') expression	# binaryExpr
		☐ expression op = ('==' | '!=') expression	# binaryExpr
		☐ // bitwise
		☐ expression op = '&' expression	# binaryExpr
		☐ expression op = '^' expression	# binaryExpr
		☐ expression op = '|' expression	# binaryExpr
		☐ // logical
		☐ <assoc = right> expression op = '&&' expression	# binaryExpr
		☐ <assoc = right> expression op = '||' expression	# binaryExpr
		☐ // assign
		☐ <assoc = right> expression op = '=' expression # assignExpr
